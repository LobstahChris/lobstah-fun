import fs from 'fs';
import path from 'path';

const TRADER_ADDRESS = "0x63ce342161250d705dc0b16df89036c8e5f9ba9a";
const DATA_API = "https://data-api.polymarket.com";
const OUTPUT_DIR = path.join(process.cwd(), "web/content/docs/lobstah-trader/trader-spotlights", TRADER_ADDRESS);
const OUTPUT_FILE = path.join(OUTPUT_DIR, "predictions.ts");

const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

async function scout() {
    console.log(`ü¶û LobstahScout: Deep-diving trader ${TRADER_ADDRESS} with backoff...`);

    try {
        // 1. Fetch Positions (latest snapshot)
        const posRes = await fetch(`${DATA_API}/positions?user=${TRADER_ADDRESS}`);
        const positions = await posRes.json();

        // 2. Discover total extent (since API doesn't give a total count, we walk back until empty)
        let allTrades: any[] = [];
        let offset = 0;
        const limit = 100;
        let consecutiveEmptyBatches = 0;

        // Note: The Data API returns newest first by default. 
        // To get "oldest to newest" from a paginated API that doesn't support 'sort=oldest',
        // we must fetch everything first, then reverse.
        
        while (true) {
            console.log(`üì° Fetching batch (offset: ${offset})...`);
            
            try {
                const tradeRes = await fetch(`${DATA_API}/trades?user=${TRADER_ADDRESS}&limit=${limit}&offset=${offset}`);
                
                if (tradeRes.status === 429) {
                    console.log("‚ö†Ô∏è Rate limited. Backing off for 5s...");
                    await sleep(5000);
                    continue;
                }

                const batch = await tradeRes.json();
                
                if (batch && Array.isArray(batch) && batch.length > 0) {
                    allTrades = allTrades.concat(batch);
                    offset += limit;
                    consecutiveEmptyBatches = 0;
                    
                    // Small delay to be polite and avoid instant 429
                    await sleep(500); 

                    if (allTrades.length >= 20000) {
                        console.log("üõë Safety ceiling reached (20k).");
                        break;
                    }
                } else {
                    console.log("üèÅ Hit empty batch. Reached the end of available history.");
                    break;
                }
            } catch (err) {
                console.error("üì° Request failed, retrying in 2s...", err);
                await sleep(2000);
            }
        }

        // 5. Load Existing Data for De-duplication
        let existingTrades: any[] = [];
        if (fs.existsSync(OUTPUT_FILE)) {
            try {
                const existingFile = fs.readFileSync(OUTPUT_FILE, 'utf-8');
                // Extract JSON from the export string
                const jsonMatch = existingFile.match(/traderData = ([\s\S]*?);/);
                if (jsonMatch) {
                    const parsed = JSON.parse(jsonMatch[1]);
                    existingTrades = parsed.trades || [];
                }
            } catch (e) {
                console.log("‚ö†Ô∏è Could not parse existing predictions.ts, starting fresh.");
            }
        }

        // Merge and De-duplicate by transactionHash or unique ID
        // Note: Data API trades have 'transactionHash' and 'timestamp'
        const tradeMap = new Map();
        [...existingTrades, ...allTrades].forEach(t => {
            const key = t.id || `${t.transactionHash}-${t.asset}-${t.timestamp}`;
            tradeMap.set(key, t);
        });

        const mergedTrades = Array.from(tradeMap.values())
            .sort((a, b) => a.timestamp - b.timestamp); // Keep chronological

        const stats = {
            totalTradesFetched: mergedTrades.length,
            activePositions: positions.length,
            totalActivePnL: positions.reduce((acc: number, p: any) => acc + (p.cashPnl || 0), 0),
            firstTradeDate: mergedTrades.length > 0 ? new Date(mergedTrades[0].timestamp * 1000).toISOString() : null,
            lastTradeDate: mergedTrades.length > 0 ? new Date(mergedTrades[mergedTrades.length - 1].timestamp * 1000).toISOString() : null
        };

        // 6. Generate the predictions.ts content
        const fileContent = `/**
 * AUTO-GENERATED BY LOBSTAH-SCOUT
 * Last Updated: ${new Date().toISOString()}
 */

export const traderData = {
    address: "${TRADER_ADDRESS}",
    stats: ${JSON.stringify(stats, null, 4)},
    positions: ${JSON.stringify(positions, null, 4)},
    trades: ${JSON.stringify(mergedTrades, null, 4)}
};
`;

        // 7. Write to file
        if (!fs.existsSync(OUTPUT_DIR)) {
            fs.mkdirSync(OUTPUT_DIR, { recursive: true });
        }
        fs.writeFileSync(OUTPUT_FILE, fileContent);

        console.log(`‚úÖ Success! ${mergedTrades.length} unique trades archived in: ${OUTPUT_FILE}`);

    } catch (error) {
        console.error("‚ùå Critical failure during scout:", error);
    }
}

scout();
